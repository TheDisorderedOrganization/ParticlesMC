var documenterSearchIndex = {"docs":
[{"location":"man/architecture/#Package-Architecture","page":"Package Architecture","title":"Package Architecture","text":"The package adopts a modular architecture, with each module responsible for a distinct component of the simulation workflow. ","category":"section"},{"location":"man/architecture/#Core-systems","page":"Package Architecture","title":"Core systems","text":"Two fundamental data structures represent physical systems: the Atoms struct for atomic systems and the Molecules struct for molecular systems.  Both structures inherit from the abstract Particles type, which itself is a subtype of AriannaSystem (see Arianna types).  This design allows the use of the Arianna.jl framework. The Atoms struct encapsulates properties such as particle positions,  atom types, and interaction potentials. The Molecules struct extends the Atoms  struct by including bond information (type and interaction potential).\n\nUsers can choose from a variety of potentials for calculating interactions between particles. The interactions depend solely on the type of the particles. For molecular systems, users choose potentials for both bonded particles and non-bonded particles. The interactions depend on the type of particles for  non-bonded interactions and on the type of bond for bonded interactions.\n\nIn both cases, the target distribution is the Boltzmann distribution and thus,  simulations are performed in the canonical ensemble (constant number of particles, volume, and temperature). An extension to perform simulations in the NPT ensemble (constant number of particles, pressure, and temperature) is in current development.","category":"section"},{"location":"man/architecture/#Monte-Carlo-Moves","page":"Package Architecture","title":"Monte Carlo Moves","text":"To use the Arianna.jl framework, the package implements moves defined through actions and policies, as described in the previous section.  The package provides a collection of predefined actions and policies corresponding to standard and state-of-the-art Monte Carlo moves in atomic and molecular simulations:\n\nStandard displacement moves.\nSwap moves for particle exchange in atomic systems.\nFlip moves in molecular systems.\nIntramolecular swap moves in polymeric systems.\n\nEach action supports multiple policy implementations. For instance, displacement moves can employ either normal  or uniform probability distributions for trial move generation.\n\nAll moves are designed to be compatible with both the Metropolis-Hastings algorithm and the Policy-Guided Monte Carlo (PGMC) method of Arianna. This means that all functions required by the Arianna.jl framework (see Arianna moves) are implemented for each action and policy.","category":"section"},{"location":"man/architecture/#Neighbour-Lists","page":"Package Architecture","title":"Neighbour Lists","text":"The package incorporates efficient neighbor list algorithms[1] to accelerate interaction computations between particles. Users can choose two neighbor list implementations, LinkedList and EmptyList. Both structs are subtypes of the  NeighbourList type. The EmptyList is a dummy neighbour list that does not store any information, and thus  the interaction between particles is computed by looping over all the particles. The LinkedList struct is  a cell list implementation that divides the simulation box into cells of size larger that the maximul cutoff of the interaction potentials. This permits to calculate the potential energy of a particle by only calculating its interactions with particles  inside the neighbouring cells. For large systems, using the LinkedList struct accelerates significantly simulations  compared to using the EmptyList struct. ","category":"section"},{"location":"man/architecture/#Input/Output","page":"Package Architecture","title":"Input/Output","text":"The package handle file operations, supporting configuration import from .xyz, .exyz, and .lammps formats. The package can also write the output trajectories in these same formats, providing users flexibility in choosing their preferred file format  for data storage and analysis.\n\nAdditionally, the package provides callback functions for on-the-fly calculation of thermodynamic and structural properties during simulations,  including energy and pressure for both atomic and molecular systems. These callbacks are stored in the output directory for post-processing.\n\n[1]: Computer simulation of liquids, Allen, Michael P and Tildesley, Dominic J, 2017","category":"section"},{"location":"api/#API","page":"API","title":"API","text":"This is the documentation of the ParticlesMC module's functions, types and structures.","category":"section"},{"location":"api/#API-Reference","page":"API","title":"API Reference","text":"","category":"section"},{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/#Types-and-Functions","page":"API","title":"Types and Functions","text":"","category":"section"},{"location":"api/#ParticlesMC.ParticlesMC","page":"API","title":"ParticlesMC.ParticlesMC","text":"ParticlesMC: Monte Carlo simulation framework for particle systems.\n\nProvides core types, utilities, and the particlesmc command implemented with Comonicon. Exports commonly-used types (e.g., Particles, Model) and helper functions for simulation control, I/O, and moves.\n\n\n\n\n\n","category":"module"},{"location":"api/#ParticlesMC.Atoms","page":"API","title":"ParticlesMC.Atoms","text":"Atoms - type representing a system of non-bonded particles.\n\nDescription Atoms{D,V,C,H,T,SM} <: Particles stores positions, species, thermodynamic properties, and neighbour-list data needed for energy and neighbour queries.\n\nFields\n\nposition::Vector{SVector{D,T}}: positions of particles.\nspecies::V: species/type identifier per particle (or per-site values).\ndensity::T, temperature::T, energy::Vector{T}: thermodynamic properties.\nmodel_matrix::SM: interaction models used for pairwise energies.\nN::Int, d::Int: number of particles and dimensionality.\nbox::SVector{D,T}: periodic box vector.\nneighbour_list::C: neighbour list structure (CellList/LinkedList/EmptyList).\nspecies_list::H: optional auxiliary species list structure.\n\n\n\n\n\n","category":"type"},{"location":"api/#ParticlesMC.Bonded","page":"API","title":"ParticlesMC.Bonded","text":"Marker indicating that a pair of particles is bonded.\n\nUsed to select the bonded contribution (bond potentials) in energy computations.\n\n\n\n\n\n","category":"type"},{"location":"api/#ParticlesMC.CellList","page":"API","title":"ParticlesMC.CellList","text":"Cell-list neighbour list implementation.\n\nFields:\n\ncs: per-particle scalar cell index\nbox: cell dimensions\nncells: number of cells per dimension\ncells: vectors of particle indices in each cell\nneighbour_cells: precomputed neighbouring cell indices for each cell\n\n\n\n\n\n","category":"type"},{"location":"api/#ParticlesMC.CellList-Union{Tuple{T}, Tuple{d}, Tuple{StaticArraysCore.SVector{d, T}, T, Int64}} where {d, T<:AbstractFloat}","page":"API","title":"ParticlesMC.CellList","text":"Construct a CellList neighbour list given a box, cutoff rcut, and particle count N.\n\nCells are chosen so that their dimensions are at least rcut, and neighbour cells are precomputed.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.ContinuousModel","page":"API","title":"ParticlesMC.ContinuousModel","text":"abstract type ContinuousModel end\n\nAn abstract base type representing a general interaction model with a continuous size polidispersity.\n\n\n\n\n\n","category":"type"},{"location":"api/#ParticlesMC.DiscreteModel","page":"API","title":"ParticlesMC.DiscreteModel","text":"abstract type DiscreteModel end\n\nAn abstract base type representing a general interaction model with a fixed number of species.\n\n\n\n\n\n","category":"type"},{"location":"api/#ParticlesMC.DiscreteSwap","page":"API","title":"ParticlesMC.DiscreteSwap","text":"DiscreteSwap - action representing swapping species between two particles.\n\nFields\n\ni::Int, j::Int: particle indices involved in the swap.\nspecies::Tuple{Int,Int}: pair of species identifiers being swapped.\nparticles_per_species::Tuple{Int,Int}: population counts used for proposal densities.\nδe::Float64: energy difference produced by the swap.\n\n\n\n\n\n","category":"type"},{"location":"api/#ParticlesMC.Displacement","page":"API","title":"ParticlesMC.Displacement","text":"mutable struct Displacement{T<:AbstractArray} <: Action\n\nA struct representing a displacement action, where particle i is moved by specified amounts δ.\n\nFields\n\ni::Int: Indices of the particles or elements in system to be displaced.\nδ::T: Displacement values for each corresponding index in is.\n\n\n\n\n\n","category":"type"},{"location":"api/#ParticlesMC.DoubleUniform","page":"API","title":"ParticlesMC.DoubleUniform","text":"DoubleUniform - proposal policy selecting one particle uniformly from each of two species lists.\n\n\n\n\n\n","category":"type"},{"location":"api/#ParticlesMC.EmptyList","page":"API","title":"ParticlesMC.EmptyList","text":"A no-op neighbour list implementation: always empty.\n\nUseful for testing or systems where no neighbour list is desired.\n\n\n\n\n\n","category":"type"},{"location":"api/#ParticlesMC.EmptyList-Tuple{Any, Any, Any}","page":"API","title":"ParticlesMC.EmptyList","text":"Construct an EmptyList (ignores box, rcut, N).\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.EnergyBias","page":"API","title":"ParticlesMC.EnergyBias","text":"EnergyBias - proposal policy biasing selection by particle energies.\n\n\n\n\n\n","category":"type"},{"location":"api/#ParticlesMC.LennardJones","page":"API","title":"ParticlesMC.LennardJones","text":"struct LennardJones{T<:AbstractArray} <: DiscreteModel\n\nA struct representing the KobAndersen interaction model where particles interact via a Lennard-Jones potential.\n\nFields\n\nname::String: A descriptive name for the model.\nϵ::T: Energy scale matrix for particle interactions between different types.\nσ::T: Characteristic length matrix for particle interactions between different types.\nrcut::T: Cutoff distance matrix beyond which interactions are neglected.\nshift::T: Shift matrix to ensure the potential is zero at the cutoff distance.\n\n\n\n\n\n","category":"type"},{"location":"api/#ParticlesMC.LinkedList","page":"API","title":"ParticlesMC.LinkedList","text":"Linked-list neighbour list implementation.\n\nUses arrays head and list to store per-cell linked lists of particle indices.\n\n\n\n\n\n","category":"type"},{"location":"api/#ParticlesMC.LinkedList-Tuple{Any, Any, Any}","page":"API","title":"ParticlesMC.LinkedList","text":"Construct a LinkedList neighbour list given box, cutoff rcut, and number of particles N.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.Model","page":"API","title":"ParticlesMC.Model","text":"abstract type Model end\n\nAn abstract base type representing a general interaction model.\n\n\n\n\n\n","category":"type"},{"location":"api/#ParticlesMC.MoleculeFlip","page":"API","title":"ParticlesMC.MoleculeFlip","text":"MoleculeFlip - action representing swapping species between two sites within the same molecule.\n\nFields\n\ni::Int, j::Int: particle indices inside the same molecule to be swapped.\nδe::F: energy change due to the swap.\n\n\n\n\n\n","category":"type"},{"location":"api/#ParticlesMC.Molecules","page":"API","title":"ParticlesMC.Molecules","text":"Molecules - type managing a collection of molecules (chains) of particles.\n\nDescription Molecules{D,VS,C,T,SM} <: Particles represents a particle system organized into molecules (or chains). It stores particle positions, molecule membership, molecule lengths and start indices, thermodynamic properties, interaction models, and the neighbour list structure used for energy and neighbour queries.\n\nFields\n\nposition::Vector{SVector{D,T}}: positions of particles.\nspecies::VS: species/type of each particle.\nmolecule::VS: molecule identifier for each particle.\nmolecule_species::VS: species identifier for each molecule.\nstart_mol::Vector{Int}: starting site index of each molecule.\nlength_mol::Vector{Int}: length (number of sites) of each molecule.\ndensity::T, temperature::T, energy::Vector{T}: thermodynamic properties.\nmodel_matrix::SM: interaction model matrix.\nd::Int, N::Int, Nmol::Int: dimension, number of particles, number of molecules.\nbox::SVector{D,T}: periodic box vector.\nneighbour_list::C: neighbour list structure (CellList/LinkedList/EmptyList).\nbonds::Vector{Vector{Int}}: lists of bonded neighbours for each particle.\n\n\n\n\n\n","category":"type"},{"location":"api/#ParticlesMC.NonBonded","page":"API","title":"ParticlesMC.NonBonded","text":"Marker indicating that a pair of particles is non-bonded.\n\nUsed to select the non-bonded pair potential contribution in energy computations.\n\n\n\n\n\n","category":"type"},{"location":"api/#ParticlesMC.SimpleGaussian","page":"API","title":"ParticlesMC.SimpleGaussian","text":"Simple isotropic Gaussian proposal policy for displacement moves.\n\n\n\n\n\n","category":"type"},{"location":"api/#ParticlesMC.SoftSpheres","page":"API","title":"ParticlesMC.SoftSpheres","text":"struct SoftSpheres{T<:AbstractArray} <: DiscreteModel\n\nA struct representing a soft-sphere interaction model where particles interact via an inverse power-law potential.\n\nFields\n\nname::String: A descriptive name for the model.\nϵ::T: Energy scale matrix for particle interactions between different types.\nσ::T: Characteristic length matrix for particle interactions between different types.\nn::Int: Exponent controlling the softness of the interaction.\nrcut::T: Cutoff distance matrix beyond which interactions are neglected.\nshift::T: Shift matrix to ensure the potential is zero at the cutoff distance.\n\n\n\n\n\n","category":"type"},{"location":"api/#Arianna.PolicyGuided.reward-Tuple{DiscreteSwap, Particles}","page":"API","title":"Arianna.PolicyGuided.reward","text":"Policy-guided reward function for DiscreteSwap (constant reward).\n\n\n\n\n\n","category":"method"},{"location":"api/#Arianna.PolicyGuided.reward-Tuple{Displacement, Particles}","page":"API","title":"Arianna.PolicyGuided.reward","text":"Reward function for Displacement under a policy-guided scheme.\n\nReturns the squared norm of the displacement (can be used as a positive reward for exploration).\n\n\n\n\n\n","category":"method"},{"location":"api/#Arianna.invert_action!-Tuple{DiscreteSwap, Particles}","page":"API","title":"Arianna.invert_action!","text":"Invert a DiscreteSwap action by swapping the stored particle indices.\n\n\n\n\n\n","category":"method"},{"location":"api/#Arianna.invert_action!-Tuple{Displacement, Particles}","page":"API","title":"Arianna.invert_action!","text":"Invert a Displacement action in-place by negating its displacement vector.\n\nThis is used to create the revert operation for a displacement move.\n\n\n\n\n\n","category":"method"},{"location":"api/#Arianna.invert_action!-Tuple{MoleculeFlip, Molecules}","page":"API","title":"Arianna.invert_action!","text":"Invert a MoleculeFlip action by swapping stored indices.\n\n\n\n\n\n","category":"method"},{"location":"api/#Arianna.log_proposal_density-Tuple{DiscreteSwap, DoubleUniform, Any, Particles}","page":"API","title":"Arianna.log_proposal_density","text":"Log proposal density for DiscreteSwap under DoubleUniform sampling.\n\n\n\n\n\n","category":"method"},{"location":"api/#Arianna.log_proposal_density-Tuple{DiscreteSwap, EnergyBias, Any, Particles}","page":"API","title":"Arianna.log_proposal_density","text":"Log proposal density for DiscreteSwap under the EnergyBias policy.\n\nThis function computes the log-probability of selecting the pair (i,j) given energy-weighted exponentials controlled by parameters.θ₁ and parameters.θ₂.\n\n\n\n\n\n","category":"method"},{"location":"api/#Arianna.log_proposal_density-Tuple{Displacement, SimpleGaussian, Any, Particles}","page":"API","title":"Arianna.log_proposal_density","text":"Compute the log proposal density of a Displacement under SimpleGaussian.\n\n\n\n\n\n","category":"method"},{"location":"api/#Arianna.log_proposal_density-Tuple{MoleculeFlip, DoubleUniform, Any, Particles}","page":"API","title":"Arianna.log_proposal_density","text":"Log proposal density for MoleculeFlip under DoubleUniform sampling (uniform between 2 choices).\n\n\n\n\n\n","category":"method"},{"location":"api/#Arianna.perform_action!-Tuple{Particles, Arianna.Action}","page":"API","title":"Arianna.perform_action!","text":"Execute an Action via the Arianna API and update the system energy.\n\nArianna.perform_action!(system, action) calls perform_action! to obtain the pre- and post-action energies (e₁, e₂), sets action.δe and updates system.energy[1] accordingly (ignoring updates when energies are Inf). It returns the tuple (e₁, e₂).\n\n\n\n\n\n","category":"method"},{"location":"api/#Arianna.revert_action!-Tuple{Particles, DiscreteSwap}","page":"API","title":"Arianna.revert_action!","text":"Revert a DiscreteSwap action by swapping species back and restoring energy.\n\nThis function also updates the species list metadata to undo the swap.\n\n\n\n\n\n","category":"method"},{"location":"api/#Arianna.revert_action!-Tuple{Particles, Displacement}","page":"API","title":"Arianna.revert_action!","text":"Revert a previously applied Displacement action.\n\nThis function applies action.δ (which should typically be the inverse displacement), restores the system energy by subtracting action.δe, and updates the neighbour list if the particle changed cell.\n\n\n\n\n\n","category":"method"},{"location":"api/#Arianna.revert_action!-Tuple{Particles, MoleculeFlip}","page":"API","title":"Arianna.revert_action!","text":"Revert a MoleculeFlip action by swapping the species back and restoring energy.\n\n\n\n\n\n","category":"method"},{"location":"api/#Arianna.sample_action!-Tuple{DiscreteSwap, DoubleUniform, Any, Particles, Any}","page":"API","title":"Arianna.sample_action!","text":"Sample indices for DiscreteSwap uniformly from the two species lists.\n\n\n\n\n\n","category":"method"},{"location":"api/#Arianna.sample_action!-Tuple{DiscreteSwap, EnergyBias, Any, Particles, Any}","page":"API","title":"Arianna.sample_action!","text":"Sample a DiscreteSwap pair under the EnergyBias policy by importance sampling based on particle energies.\n\n\n\n\n\n","category":"method"},{"location":"api/#Arianna.sample_action!-Tuple{Displacement, SimpleGaussian, Any, Particles, Any}","page":"API","title":"Arianna.sample_action!","text":"Sample a Displacement action under SimpleGaussian.\n\nChooses a random particle index and draws an isotropic Gaussian displacement of dimension system.d with standard deviation parameters.σ.\n\n\n\n\n\n","category":"method"},{"location":"api/#Arianna.sample_action!-Tuple{MoleculeFlip, DoubleUniform, Any, Particles, Any}","page":"API","title":"Arianna.sample_action!","text":"Sample a MoleculeFlip action by selecting a molecule uniformly and picking two distinct sites in that molecule with different species.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.eachindex-Tuple{Particles}","page":"API","title":"Base.eachindex","text":"Return a proper index range for system.\n\nOverloads Base.eachindex to allow fast indexing.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{Atoms, Int64}","page":"API","title":"Base.getindex","text":"Return the (position, species) tuple for atom i.\n\nThis overload supports indexing atoms[i] to get coordinates and species.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.iterate","page":"API","title":"Base.iterate","text":"Iterate over Atoms or Molecules returning the position and next state.\n\nConforms to Julia iterator interface; yields the position of the current index.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.length-Tuple{Particles}","page":"API","title":"Base.length","text":"Return the number of particles in system.\n\nOverloads Base.length for Particles.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.System-Union{Tuple{T}, Tuple{Any, Any, Any, T, T, Any, Any}} where T<:AbstractFloat","page":"API","title":"ParticlesMC.System","text":"Create a Molecules system and initialize neighbour list and energy.\n\nSystem(position, species, molecule, density, temperature, model_matrix, bonds; molecule_species=nothing, list_type=EmptyList) builds and returns a Molecules instance. It computes start_mol/length_mol, constructs the neighbour list of type list_type, builds it, and computes the initial total energy (with a check for Inf/NaN).\n\nArguments\n\nposition: vector of particle positions.\nspecies: species identifier per particle.\nmolecule: molecule id per particle.\ndensity, temperature: thermodynamic scalars.\nmodel_matrix: interaction models used to compute energies.\nbonds: bonded neighbour lists for each particle.\n\nReturns\n\nMolecules instance with neighbour list built and energy[1] set.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.System-Union{Tuple{T}, Tuple{Any, Any, T, T, Any}} where T<:AbstractFloat","page":"API","title":"ParticlesMC.System","text":"Create an Atoms system, initialize its neighbour list, and compute initial energy.\n\nSystem(position, species, density, temperature, model_matrix; list_type=EmptyList) constructs an Atoms instance, builds the neighbour list of type list_type, and computes the initial total energy (stored in system.energy[1]).\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.build_neighbour_cells-Union{Tuple{NTuple{d, Int64}}, Tuple{d}} where d","page":"API","title":"ParticlesMC.build_neighbour_cells","text":"Build for each scalar cell index the list of neighbouring cells (including itself).\n\nReturns a vector where element c contains a vector of scalar indices of neighbouring cells.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.build_neighbour_list!-Tuple{Particles, CellList}","page":"API","title":"ParticlesMC.build_neighbour_list!","text":"Populate neighbour_list (a CellList) with particle indices from system.\n\nAssigns each particle to its corresponding cell and appends it to that cell's list.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.build_neighbour_list!-Tuple{Particles, EmptyList}","page":"API","title":"ParticlesMC.build_neighbour_list!","text":"No-op build for EmptyList.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.build_neighbour_list!-Tuple{Particles, LinkedList}","page":"API","title":"ParticlesMC.build_neighbour_list!","text":"Populate neighbour_list (a LinkedList) by constructing head/list linked lists per cell.\n\nResets headers and inserts particles into per-cell linked lists efficiently.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.build_neighbour_list!-Tuple{Particles}","page":"API","title":"ParticlesMC.build_neighbour_list!","text":"Build or update the neighbour list for system using its current neighbour list type.\n\nThis dispatches to the concrete build_neighbour_list! method for the active neighbour list implementation.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.cell_index-Union{Tuple{d}, Tuple{NTuple{d, Int64}, NTuple{d, Int64}}} where d","page":"API","title":"ParticlesMC.cell_index","text":"Compute a scalar cell index from the multi-dimensional cell coordinate mc.\n\nUses row-major ordering with periodic boundary treatment via fold_back.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.cell_index-Union{Tuple{d}, Tuple{NeighbourList, NTuple{d, Int64}}} where d","page":"API","title":"ParticlesMC.cell_index","text":"Return the scalar cell index corresponding to mc using neighbour_list metadata.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.check_compute_energy_ij-Tuple{Molecules, Vararg{Any, 4}}","page":"API","title":"ParticlesMC.check_compute_energy_ij","text":"Check and compute the pair energy between particles i and j.\n\ncheck_compute_energy_ij(system, i, j, position_i, bonds_i) returns the pair energy between i and j. If i == j it returns zero. It determines whether the pair is bonded and dispatches to compute_energy_ij with the appropriate marker (Bonded or NonBonded).\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.check_nonbonded_compute_energy_ij-Tuple{Molecules, Vararg{Any, 4}}","page":"API","title":"ParticlesMC.check_nonbonded_compute_energy_ij","text":"check_nonbonded_compute_energy_ij returns zero if i == j or if j is bonded to i. Otherwise it computes the non-bonded pair energy by dispatching to compute_energy_ij(..., NonBonded()).\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.comonicon_install-Tuple{}","page":"API","title":"ParticlesMC.comonicon_install","text":"comonicon_install(;kwargs...)\n\nInstall the CLI manually. This will use the default configuration in Comonicon.toml, if it exists. For more detailed reference, please refer to Comonicon documentation.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.comonicon_install_path-Tuple{}","page":"API","title":"ParticlesMC.comonicon_install_path","text":"comonicon_install_path(;[yes=false])\n\nInstall the PATH and FPATH to your shell configuration file. You can use comonicon_install_path(;yes=true) to skip interactive prompt. For more detailed reference, please refer to Comonicon documentation.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.compute_chain_correlation-Tuple{Molecules}","page":"API","title":"ParticlesMC.compute_chain_correlation","text":"Compute a measure of chain correlation for monodisperse chains.\n\ncompute_chain_correlation(system) assumes all chains have the same length and computes the squared sum of pairwise cross-correlations between different chain sites over all chains (useful as an order parameter).\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.compute_energy_ij-Tuple{Atoms, Any, Any, Any}","page":"API","title":"ParticlesMC.compute_energy_ij","text":"Compute the pair energy between particles i and j for an Atoms system.\n\nReturns zero if i == j or if the squared distance exceeds the model's cutoff. Otherwise returns potential(r2, model_ij) where r2 is the squared nearest-image distance.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.compute_energy_ij-Tuple{Molecules, Any, Any, Model, ParticlesMC.NonBonded}","page":"API","title":"ParticlesMC.compute_energy_ij","text":"Compute non-bonded pair energy using pair potential with cutoff.\n\nThis method is chosen when the pair marker is NonBonded. It returns zero if the squared distance exceeds the model's cutoff squared, otherwise returns the pair potential potential(r2, model_ij).\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.compute_energy_particle-Tuple{Atoms, Any, CellList}","page":"API","title":"ParticlesMC.compute_energy_particle","text":"Compute the energy of particle i using a CellList neighbour list.\n\nThis restricts pair evaluations to particles in neighbouring cells of i.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.compute_energy_particle-Tuple{Atoms, Any, EmptyList}","page":"API","title":"ParticlesMC.compute_energy_particle","text":"Compute the energy of particle i by brute force (no neighbour list).\n\ncompute_energy_particle(system, i, ::EmptyList) sums interactions of particle i with all other particles using compute_energy_ij.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.compute_energy_particle-Tuple{Atoms, Any, LinkedList}","page":"API","title":"ParticlesMC.compute_energy_particle","text":"Compute the energy of particle i using a LinkedList neighbour list.\n\nThis variant iterates linked list heads for neighbouring cells and accumulates pair energies computed with compute_energy_ij.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.compute_energy_particle-Tuple{Molecules, Any, CellList}","page":"API","title":"ParticlesMC.compute_energy_particle","text":"Compute particle energy using a CellList neighbour list.\n\nThis variant restricts non-bonded pair evaluation to particles in neighbouring cells defined by the cell list; bonded contributions are added explicitly.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.compute_energy_particle-Tuple{Molecules, Any, EmptyList}","page":"API","title":"ParticlesMC.compute_energy_particle","text":"Compute particle energy by brute force (no neighbour list).\n\ncompute_energy_particle(system, i, ::EmptyList) sums interactions of particle i with all particles (including bonded and non-bonded contributions via helper functions). Used when no neighbour list is available.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.compute_energy_particle-Tuple{Molecules, Any, LinkedList}","page":"API","title":"ParticlesMC.compute_energy_particle","text":"Compute particle energy using a LinkedList neighbour list.\n\nThis variant restricts non-bonded pair evaluation to particles in neighbouring cells defined by the linked list; bonded contributions are added explicitly.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.compute_energy_particle-Tuple{Particles, AbstractVector}","page":"API","title":"ParticlesMC.compute_energy_particle","text":"Compute the energy contribution for each particle index in ids.\n\nReturns an array with per-particle energies by mapping compute_energy_particle.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.compute_energy_particle-Tuple{Particles, Int64}","page":"API","title":"ParticlesMC.compute_energy_particle","text":"Compute the energy contribution of particle i in system using its neighbour list.\n\nIf a neighbour list is provided it will be used for the evaluation.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.get_box-Tuple{Particles}","page":"API","title":"ParticlesMC.get_box","text":"Return the simulation box of system.\n\nReturns\n\nBox description (usually vector or struct) representing periodic box extents.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.get_cell-Union{Tuple{T}, Tuple{d}, Tuple{StaticArraysCore.SVector{d, T}, NeighbourList}} where {d, T<:AbstractFloat}","page":"API","title":"ParticlesMC.get_cell","text":"Return the multi-dimensional cell coordinate for position xi using neighbour_list metadata.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.get_cell-Union{Tuple{T}, Tuple{d}, Tuple{StaticArraysCore.SVector{d, T}, StaticArraysCore.SVector{d, T}}} where {d, T<:AbstractFloat}","page":"API","title":"ParticlesMC.get_cell","text":"Return the multi-dimensional cell coordinate for position xi in box.\n\nResult is an NTuple{d,Int} giving the cell index in each dimension.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.get_cell_index-Tuple{Int64, NeighbourList}","page":"API","title":"ParticlesMC.get_cell_index","text":"Return the scalar cell index of particle i stored in neighbour_list.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.get_cell_index-Union{Tuple{T}, Tuple{d}, Tuple{StaticArraysCore.SVector{d, T}, NeighbourList}} where {d, T<:AbstractFloat}","page":"API","title":"ParticlesMC.get_cell_index","text":"Return the scalar cell index for position xi using neighbour_list.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.get_first_and_counts-Tuple{Vector{Int64}}","page":"API","title":"ParticlesMC.get_first_and_counts","text":"Return arrays of first indices and counts for consecutive blocks in vec.\n\nget_first_and_counts(vec) scans vec and returns a tuple (firsts, counts), where firsts are the starting indices of each run and counts the corresponding lengths.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.get_model-Tuple{Particles, Int64, Int64}","page":"API","title":"ParticlesMC.get_model","text":"Return the interaction Model between the species of particles i and j.\n\nArguments\n\nsystem::Particles: the particle system\ni::Int, j::Int: particle indices\n\nReturns\n\nModel object or callable describing pair interactions for the two species.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.get_neighbour_list-Tuple{Particles}","page":"API","title":"ParticlesMC.get_neighbour_list","text":"Return the neighbour list of system.\n\nReturns\n\nThe neighbour list object used for pair evaluations (e.g., NeighbourList, LinkedList).\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.get_position-Tuple{Particles, Int64}","page":"API","title":"ParticlesMC.get_position","text":"Return the position of particle i in system.\n\nArguments\n\nsystem::Particles: the particle system\ni::Int: particle index\n\nReturns\n\nCoordinates of particle i (e.g., an SVector or array).\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.get_species-Tuple{Particles, Int64}","page":"API","title":"ParticlesMC.get_species","text":"Return the species index (type) of particle i.\n\nArguments\n\nsystem::Particles: the particle system\ni::Int: particle index\n\nReturns\n\nInt: species identifier of particle i.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.get_start_end_mol-Tuple{Particles, Int64}","page":"API","title":"ParticlesMC.get_start_end_mol","text":"Return the start and end indices of molecule i in system.\n\nget_start_end_mol(system, i) returns a tuple (start, end) for the i-th molecule, where start is the first particle index and end is the last particle index.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.old_new_cell-Tuple{Particles, Any, CellList}","page":"API","title":"ParticlesMC.old_new_cell","text":"Return the old and new cell indices for particle i in neighbour_list (CellList).\n\nUsed to detect whether a particle has moved between cells.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.old_new_cell-Tuple{Particles, Any, EmptyList}","page":"API","title":"ParticlesMC.old_new_cell","text":"Return placeholder old and new cell indices for EmptyList.\n\nAlways returns (1,1) as no cells are tracked.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.old_new_cell-Tuple{Particles, Any, LinkedList}","page":"API","title":"ParticlesMC.old_new_cell","text":"Return old and new cell indices for particle i using a LinkedList neighbour list.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.particlesmc","page":"API","title":"ParticlesMC.particlesmc","text":"ParticlesMC implemented in Comonicon.\n\nArguments\n\nparams: Path to the TOML parameter file.\n\n\n\n\n\n","category":"function"},{"location":"api/#ParticlesMC.perform_action!-Tuple{Particles, DiscreteSwap}","page":"API","title":"ParticlesMC.perform_action!","text":"Execute a DiscreteSwap action: swap species of particles i and j, store action.δe, and update the species list auxiliary structure.\n\nReturns (E_before, E_after) for the swapped particles.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.perform_action!-Tuple{Particles, Displacement}","page":"API","title":"ParticlesMC.perform_action!","text":"Perform a displacement action: compute pre-move energy, apply the displacement, update the neighbour list if the particle changed cell, then compute post-move energy and store the energy change in action.δe.\n\nReturns the tuple (e₁, e₂) of energies before and after the move.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.perform_action!-Tuple{Particles, MoleculeFlip}","page":"API","title":"ParticlesMC.perform_action!","text":"Perform a MoleculeFlip action by swapping species between two sites within a molecule. Returns the pair energy before and after the swap (e₁, e₂) and stores δe.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.reward-Tuple{MoleculeFlip, Particles}","page":"API","title":"ParticlesMC.reward","text":"Reward function for MoleculeFlip (currently constant).\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.swap_particle_species!-Tuple{Particles, Vararg{Any, 4}}","page":"API","title":"ParticlesMC.swap_particle_species!","text":"Swap the species identifiers of particles i and j and return the total pre- and post-swap energies for those two particles.\n\nswap_particle_species!(system, spi, i, spj, j) computes energies before the swap, performs the species exchange, then computes energies after and returns (E_before, E_after) for the pair.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.update_neighbour_list!-Tuple{Any, Any, Any, CellList}","page":"API","title":"ParticlesMC.update_neighbour_list!","text":"Update particle i moving from cell c to cell c2 in a CellList.\n\nPerforms an in-place removal from the old cell and appends to the new one.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.update_neighbour_list!-Tuple{Any, Any, Any, EmptyList}","page":"API","title":"ParticlesMC.update_neighbour_list!","text":"No-op update for EmptyList.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.update_neighbour_list!-Tuple{Int64, Int64, Int64, LinkedList}","page":"API","title":"ParticlesMC.update_neighbour_list!","text":"Update particle i moving from cell c to c2 in a LinkedList.\n\nPerforms linked-list updates handling header and interior-node cases.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.update_position!-Tuple{Particles, Displacement}","page":"API","title":"ParticlesMC.update_position!","text":"Apply the displacement contained in action to the particle(s) in system.\n\nupdate_position!(system, action::Displacement) updates system.position[action.i] by adding action.δ in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/#ParticlesMC.update_species_list!-NTuple{4, Any}","page":"API","title":"ParticlesMC.update_species_list!","text":"Update auxiliary species list metadata after swapping particles i and j.\n\nupdate_species_list!(species_list, swap_species, i, j) updates the internal spids and spheads structures to reflect the swap between indices i and j.\n\n\n\n\n\n","category":"method"},{"location":"man/simulations/#Running-simulations","page":"Running simulations","title":"Running simulations","text":"To perform a MC simulation of atomic or molecular systems, the procedure outlined in Arianna should be followed. The first step involves initializing the system, represented by either an Atoms or Molecules structure. This requires specifying  an initial configuration (including bonding information in the molecular case), the interaction potentials between different particle types,  as well as the system’s density and temperature. Subsequently, the desired Arianna.jl MCMC algorithm and the corresponding set of Monte Carlo moves are selected. The next step consists of defining the simulation parameters, such as the total number of steps, the burn-in period, and the output directory. Once these elements have been specified, the simulation can be executed.\n\nThis procedure can be carried out in two ways: either through the command-line interface (CLI) or programmatically within a Julia script,  following the approach illustrated in Arianna.jl examples. We detail here the CLI method, which is more user-friendly.","category":"section"},{"location":"man/simulations/#Using-the-command-line-interface","page":"Running simulations","title":"Using the command-line interface","text":"The CLI allows you to run simulations directly from the terminal. The basic command structure is as follows\n\nparticlesmc params.toml\n\nwhere params.toml is a parameter file written in TOML format that specifies the simulation settings. The TOML file must provide the following information:\n\nThe [system] section specifies the input configuration file, the simulation temperature and density, and the type of neighbour list.\nThe [model] section defines the interaction potential between particles. \nThe [simulation] section sets the simulation type to Metropolis, the number of Monte Carlo steps, the random seed, whether to run in parallel, and the output path.\nThe [[simulation.move]] section describes the Monte Carlo move to use.\nThe [[simulation.output]] section configures the output (trajectories and callbacks).","category":"section"},{"location":"man/simulations/#Example:-Simulating-a-Lennard-Jones-fluid","page":"Running simulations","title":"Example: Simulating a Lennard-Jones fluid","text":"We perform a Monte Carlo simulation of a simple Lennard-Jones fluid using the package's CLI. As explained above, we need to create a parameter file in TOML format that specifies the simulation settings. An example of the parameter file is presented below for simulating a Lennard-Jones fluid at temperature T=10 and number density rho=10.\n\n[system]\nconfig = \"config.xyz\"\ntemperature = 1.0\ndensity = 1.0\nlist_type = \"LinkedList\"\n\n[model]\n[model.\"1-1\"]\nname = \"LennardJones\"\nepsilon = 1.0\nsigma = 1.0\nrcut = 2.5\n\n[simulation]\ntype = \"Metropolis\"\nsteps = 500   \noutput_path = \"./\"\n\n[[simulation.move]]\naction = \"Displacement\"\nprobability = 1.0\npolicy = \"SimpleGaussian\"\nparameters = {sigma = 0.05}\n\n[[simulation.output]]\nalgorithm = \"StoreCallbacks\"\ncallbacks = [\"energy\", \"acceptance\"]\nscheduler_params = {linear_interval = 100}\n\n[[simulation.output]]\nalgorithm = \"StoreTrajectories\"\nscheduler_params = {linear_interval = 100}\nfmt = \"XYZ\"\n\nThis example defines a minimal Monte Carlo simulation setup:\n\nThe [system] The input configuration file is `config.xyz', the temperature is 1.0 and the density is 1.0. The neighbor list type is a linked list.\nThe [model] The interaction potential is a Lennard-Jones potential is used for species pair 1--1 with specified parameters (epsilon, sigma, and cutoff rcut).\nThe [simulation] The Arianna.jl MCMC method use is the Metropolis algorithm, the number of Monte Carlo steps is set to 500, and the output path is the simulation directory\nThe [[simulation.move]] The Monte Carlo move is a displacement move with probability 1.0, guided by a simple Gaussian policy with a standard deviation (sigma) of 0.05.\nThe [[simulation.output]] Two output algorithms are specified: one to store callbacks (energy and acceptance rate) every 100 steps, and another to store trajectories in XYZ format every 100 steps.\n\nExecuting the particlesmc params.toml command will run a basic Metropolis Monte Carlo simulation of particles  interacting via the Lennard-Jones potential, using displacement moves, and periodically saving the system's trajectory.  When the simulation ends, a file containing a summary of the simulation will be created in the output path.\n\nThis is a basic example of how to set up and run a Monte Carlo simulation using the package's CLI. Users can modify and extend this example to  simulate a variety of atomic and molecular systems by changing the interactions, moves, and simtulation parameters.","category":"section"},{"location":"","page":"Home","title":"Home","text":"<h1 align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/TheDisorderedOrganization/ParticlesMC/main/logo.png\" width=\"500\"/>\n</h1>\n\n\n\n<p align=\"center\">\nParticlesMC is a Julia package for performing atomic and molecular Monte Carlo simulations. It is designed to be efficient and user-friendly, making it suitable for both research and educational purposes. Built on top of the <a href=\"https://github.com/TheDisorderedOrganization/Arianna.jl\"> Arianna </a> module, it leverages Arianna’s Monte Carlo framework.\n</p>\n\n<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/TheDisorderedOrganization/ParticlesMC/main/examples/movie/movie.gif\" alt=\"MC simulation of a 2D liquid\" width=\"400\">\n</p>\n\n<p align=\"center\">\n  MC simulation of a 2D liquid. This example can be reproduced by running <code>particlesmc params.toml</code> in the <code>examples/movie/</code> folder. Movie generated with <a href=\"https://www.ovito.org/\"> ovito</a>.\n</p>","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Flexible execution: Simulations can be run from standalone scripts or through a command-line interface (CLI), enabling easy integration into workflows.\nInteraction potentials: Supports a broad range of interatomic and intermolecular interaction potentials.\nMonte Carlo moves: Implements state-of-the-art Monte Carlo moves for both atomic and molecular simulations.\nComputational efficiency: Designed with performance in mind to enable fast simulations.\nArianna framework integration: Leverages the Arianna Monte Carlo framework, benefiting from advanced techniques such as Policy-Guided Monte Carlo (PGMC) and parallel tempering (soon).","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#Requirements","page":"Home","title":"Requirements","text":"Julia version 1.9 or higher","category":"section"},{"location":"#Installing-ParticlesMC","page":"Home","title":"Installing ParticlesMC","text":"You can install ParticlesMC using the Julia package manager in one of two ways:\n\nUsing the package mode (press ] in the Julia REPL):\n\nadd https://github.com/TheDisorderedOrganization/ParticlesMC.git\n\nUsing the Pkg API:\n\nusing Pkg\nPkg.add(url=\"https://github.com/TheDisorderedOrganization/ParticlesMC.git\")","category":"section"},{"location":"#Building-ParticlesMC","page":"Home","title":"Building ParticlesMC","text":"The build should be automatic when installing ParticlesMC. If it hasn't, you can manually build the package, by entering the package mode (press ] in the Julia REPL) and by typing:\n\nbuild\n\nThis will build the particlesmc executable at ~/.julia/bin (please add this path to your PATH).","category":"section"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"#Running-a-Monte-Carlo-Simulation","page":"Home","title":"Running a Monte Carlo Simulation","text":"To run a Monte Carlo simulation, you need an input atomic or molecular configuration file (typically with a .xyz extension) and a parameter file (in TOML format). The parameter file specifies both the system details (such as temperature, density, and interaction model) and the simulation details (such as simulation type, number of steps, Monte Carlo moves, and outputs). A minimal example is presented below. More detailed explanations can be found in the documentation.\n\nconfig.xyz\n\n3\nLattice=\"1.7321 0.0 0.0 0.0 1.7321 0.0 0.0 0.0 0.0\" Properties=type:I:1:pos:R:2\n1 0.1585 0.4965\n1 1.7215 0.7468\n1 0.7606 1.1439\n\nparams.toml\n\n[system]\nconfig = \"config.xyz\"\ntemperature = 1.0\ndensity = 1.0\nlist_type = \"LinkedList\"\n\n[model]\n[model.\"1-1\"]\nname = \"LennardJones\"\nepsilon = 1.0\nsigma = 1.0\nrcut = 2.5\n\n[simulation]\ntype = \"Metropolis\"\nsteps = 500\nseed = 10\nparallel = false\noutput_path = \"./\"\n\n[[simulation.move]]\naction = \"Displacement\"\nprobability = 1.0\npolicy = \"SimpleGaussian\"\nparameters = {sigma = 0.05}\n\n[[simulation.output]]\nalgorithm = \"StoreTrajectories\"\nscheduler_params = {linear_interval = 50}\nfmt = \"XYZ\"\n\nExplanation of the example:\n\nThis example defines a minimal Monte Carlo simulation setup:\n\nThe [system] section specifies the input configuration file (config.xyz), the simulation temperature and density, and the use of a linked list for neighbor searching.\nThe [model] section defines the interaction potential between particles. Here, a Lennard-Jones potential is used for species pair \"1-1\" with specified parameters (epsilon, sigma, and cutoff rcut).\nThe [simulation] section sets the simulation type to Metropolis, the number of Monte Carlo steps to 500, the random seed, whether to run in parallel, and the output path.\nThe [[simulation.move]] section describes the Monte Carlo move to use: a displacement move with probability 1.0, guided by a simple Gaussian policy with a standard deviation (sigma) of 0.05.\nThe [[simulation.output]] section configures the output: trajectories will be stored every 50 steps in the XYZ format.\n\nBy executing `particlesmc params.toml** you will run a basic Metropolis Monte Carlo simulation of particles interacting via the Lennard-Jones potential, using displacement moves, and periodically saving the system's trajectory.\n\nExtending beyond this simple example:\n\nMore models and moves are available.\n\nFor instance, in a simulation that contains multiple species, DiscreteSwap moves can be added to swap species between to random particles:\n\n[[simulation.move]]\naction = \"DiscreteSwap\"\nprobability = 0.1\npolicy = \"DoubleUniform\"\nparameters = {species = [1, 2]}\n\nis a move that will be attempted 10% of the time (probability = 0.1). It will select a random particle i of species 1, a random particle j of species 2, and will attempt to transform i into species 2, and j into species 1.","category":"section"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"We welcome contributions from the community. If you have a new system or feature to add, please fork the repository, make your changes, and submit a pull request.","category":"section"},{"location":"#Citing","page":"Home","title":"Citing","text":"If you use Arianna in your research, please cite it! You can find the citation information in the CITATION file or directly through GitHub's \"Cite this repository\" button.","category":"section"},{"location":"#License","page":"Home","title":"License","text":"This project is licensed under the GNU General Public License v3.0.  License. See the LICENSE file for details.","category":"section"},{"location":"#Contact","page":"Home","title":"Contact","text":"For any questions or issues, please open an issue on the GitHub repository or contact the maintainers.","category":"section"},{"location":"man/particlesmc/#Molecular-Monte-Carlo","page":"Molecular Monte Carlo","title":"Molecular Monte Carlo","text":"To see an introduction to Markov Chain Monte Carlo, please read Arianna's documentation.","category":"section"},{"location":"man/particlesmc/#Birth-of-Molecular-MCMC","page":"Molecular Monte Carlo","title":"Birth of Molecular MCMC","text":"The pioneering application of the Metropolis algorithm by Metropolis et al.[1] focused on sampling the equilibrium distribution of a system consisting of N = 224 hard disks. A microstate of the system is fully characterized by the set of particle positions in space, x =  mathbfr_j _j=1^N  where mathbfr_j denotes the position of particle j. Consequently, the configuration space is the 2N-dimensional space of particle coordinates.\n\nThe target distribution P corresponds to the Boltzmann distribution, whose probability density is given by:\n\np_B(x) propto expleft-fracU(x)Tright\n\nwhere U(x) is the potential energy associated with configuration x, and T denotes the temperature of the system.\n\nThe proposed Monte Carlo move in their study consists of sequentially displacing the disks by a random vector with uniformly distributed magnitude and direction. Each particle displacement from x to x is accepted or rejected according to the Metropolis acceptance probability,\n\nalpha(xx) = min left 1 expleft-fracDelta UTright right\n\nwhere Delta U = U(x) - U(x) represents the change in potential energy resulting from the proposed displacement. In this hard disk case, the difference is either infinity or 0 depending if the displaced disk overlaps with another disk or not. We directly see that detailed balance is not respected as particles are not selected at random but sequentially,  meaning that q(x x) neq q(x x).\n\nThat is why this displacement move has later been modified in two steps, such that it respects detailed balance: \n\nSelect a particle uniformly at random from the system.\nDisplace the chosen particle by a random vector with uniformly distributed magnitude and direction.\n\nThis simple move type subsequently became the standard Monte Carlo move in liquid-state physics and remains widespread today.  Notably, the original simulation determined numerically the equation of state for this system.\n\nThe simulation was performed on the Los Alamos MANIAC I computer (Mathematical Analyzer Numerical Integrator and Automatic Computer Model I).  The researchers conducted a burn-in (equilibration) phase of 16 sweeps (where one sweep consists of N attempted moves), followed by a production run of 48 to 64 sweeps.  Each sweep required approximately 3 minutes of computation time, resulting in a total runtime of about 4 hours. By contrast, the same calculation would take approximately  10 milliseconds on a modern laptop, representing a performance improvement of roughly six orders of magnitude.\n\n<h1 align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/TheDisorderedOrganization/ParticlesMC/main/docs/src/assets/maniac.jpg\" width=\"500\"/>\n</h1>\n\n<p align=\"center\"> The MANIAC I computer at Los Alamos National Laboratory, where Arianna Rosenbluth implemented the first MCMC algorithm. \nThis machine represented the cutting edge of computational capability in the 1950s. Image taken from Ref.~\\cite{maniac}.</p>","category":"section"},{"location":"man/particlesmc/#Monte-Carlo-Moves:-Actions-and-Policies","page":"Molecular Monte Carlo","title":"Monte Carlo Moves: Actions and Policies","text":"The transition from state x to state x in the MH algorithm is commonly referred to as a Monte Carlo move. Monte Carlo moves can be conceptually decomposed into two components[2]:\n\nActions: The type of modification applied to the system (e.g., particle displacement, rotation, swap, flip).\nPolicies: The probabilistic rules governing how the action parameters are sampled (e.g., the distribution of displacement magnitudes and directions). Policies can be symmetric or non-symmetric. If a policy is symmetric, then the Metropolis algorithm is employed, else the Metropolis-Hastings algorithm is employed.\n\nTo illustrate this distinction, consider the move employed in the original Metropolis simulation. The action is the translation of a randomly selected particle.  To satisfy the detailed balance condition with the symmetric Metropolis acceptance rule, the translation's direction and magnitude can be sampled from a symmetric distribution, for example uniform, Gaussian, exponential, etc. The choice of this distribution constitutes the policy.\n\nTransitions between successive states, x_i to x_i+1, need not be governed by a single type of Monte Carlo move. In practice, it is often advantageous to define a pool of  distinct move types and to select one randomly from this pool at each step of the Markov chain. To each move type m in the pool, one assigns a selection probability  p_m, with the normalization condition sum_m p_m = 1. This collection of moves, together with their associated probabilities, can be regarded as a single composite Monte Carlo move.","category":"section"},{"location":"man/particlesmc/#Choosing-the-right-parameters","page":"Molecular Monte Carlo","title":"Choosing the right parameters","text":"\n<h1 align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/TheDisorderedOrganization/ParticlesMC/main/docs/src/assets/goodpolicy.png\" width=\"800\"/>\n</h1>\n\n<p align=\"center\"> Markov chain state space exploration for three different displacement policies. The system is a 1D particle in a potential well $U(x)$, with the target distribution being the Boltzmann distribution. The proposed move is the following: the action is the displacement of the particle and the policy is the distribution of the displacement magnitude and direction. Here, the policy is an uniform law $\\sim \\mathcal{U}(-u,u)$ with $u>0$. Each dot represents a state in the Markov chain, constructed from bottom to top. The horizontal position of a dot is the position of the particle. <b>Center:</b> When $u$ is too small, all moves are accepted but the state space is explored inefficiently due to small step sizes. <b>Right:</b> When $u$ is too large, nearly all moves are rejected, again leading to poor exploration. <b>Left:</b> An optimal choice of $u$ balances acceptance rate and step size, achieving efficient state space sampling. This illustrates the importance of tuning the proposal distribution.</p>\n\nA MCMC simulation consists of two phases: a burn-in phase and an equilibrium phase[3]. During burn-in, initial samples are discarded because the chain has not yet reached its stationary distribution. Starting from an arbitrary initial state, early samples may overweight  low-probability regions of the state space. The burn-in period must be long enough to allow the chain to converge to the target distribution before collecting samples for analysis.\n\nOnce the chain reaches equilibrium, samples are collected to estimate properties of the system. The simulation must run long enough to  adequately explore the state space mathcalX. However, successive samples are typically correlated, reducing the effective sample size. To assess sampling quality, one should examine autocorrelation functions and apply convergence diagnostics to verify that the chain has sufficiently explored mathcalX[4].\n\nThe choice of actions and policies is critical for efficient sampling. As shown in the above Figure, a poorly chosen policy leads to  inefficient exploration of the state space. Finding optimal actions and policies are essential for effective MCMC sampling.\n\n[1]: Equation of State Calculations by Fast Computing Machines, Metropolis, Nicholas and Rosenbluth, Arianna W. and Rosenbluth, Marshall N. and Teller, Augusta H. and Teller, Edward, 1953\n\n[2]: Reinforcement learning: An introduction, Sutton, Richard S and Barto, Andrew G and others, 1998\n\n[3]: Monte Carlo methods, Guiselin, Benjamin, 2024\n\n[4]: Convergence diagnostics for markov chain monte carlo, Roy, Vivekananda, 2020","category":"section"}]
}
